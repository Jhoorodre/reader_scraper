import { NewSussyToonsProvider } from '../providers/scans/sussytoons';
import fs from 'fs';
import Bluebird from 'bluebird';
import { downloadImage } from '../download/images';
import { promptUser } from '../utils/prompt';
import path from 'path';
import { ChapterLogger } from '../utils/chapter_logger';
import { TimeoutManager } from '../services/timeout_manager';

async function executeAutoRentry(): Promise<void> {
    const chapterLogger = new ChapterLogger();
    const provider = new NewSussyToonsProvider();
    const reportFile = 'download_report.txt';
    
    // Aplicar timeouts progressivos no provider
    provider.applyProgressiveTimeouts();
    
    console.log('\n' + '='.repeat(80));
    console.log('üîÑ MODO RENTRY AUTOM√ÅTICO ATIVADO');
    console.log('='.repeat(80));
    
    // Verificar se h√° falhas para reprocessar
    if (!chapterLogger.hasFailedChapters()) {
        console.log('‚úÖ Nenhuma falha encontrada nos logs - rentry n√£o necess√°rio');
        return;
    }
    
    // Obter todas as falhas dos logs
    const allFailedWorks = chapterLogger.getAllFailedChapters();
    const totalFailed = allFailedWorks.reduce((acc, work) => acc + work.chapters.length, 0);
    
    console.log(`üìã Encontradas ${allFailedWorks.length} obras com falhas para reprocessar:`);
    allFailedWorks.forEach(work => {
        console.log(`  - ${work.workName}: ${work.chapters.length} cap√≠tulos falhados`);
    });
    console.log(`üìä Total: ${totalFailed} cap√≠tulos para reprocessar\n`);
    
    fs.appendFileSync(reportFile, `\n${'='.repeat(80)}\nüîÑ MODO RENTRY AUTOM√ÅTICO INICIADO\n${'='.repeat(80)}\n`);
    
    let totalReprocessed = 0;
    let totalStillFailed = 0;
    
    // Processar cada obra com falhas
    for (let workIndex = 0; workIndex < allFailedWorks.length; workIndex++) {
        const failedWork = allFailedWorks[workIndex];
        const workName = failedWork.workName;
        const failedChapters = failedWork.chapters;
        
        console.log(`\n${'='.repeat(60)}`);
        console.log(`üîÑ Reprocessando obra ${workIndex + 1}/${allFailedWorks.length}: ${workName}`);
        console.log(`üìä Cap√≠tulos falhados: ${failedChapters.length}`);
        console.log(`${'='.repeat(60)}`);
        
        fs.appendFileSync(reportFile, `\n=== RENTRY OBRA ${workIndex + 1}: ${workName} ===\n`);
        
        // Processar cada cap√≠tulo falhado desta obra
        for (const failedChapter of failedChapters) {
            console.log(`\nüîÑ Reprocessando: ${failedChapter.chapterNumber}`);
            
            let reprocessSuccess = false;
            let lastError = null;
            const maxRetries = 3;
            
            // 3 novas tentativas para cada cap√≠tulo
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    if (attempt > 1) {
                        console.log(`üîÑ Tentativa ${attempt}/${maxRetries} para: ${failedChapter.chapterNumber}`);
                        await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                    }
                    
                    // Criar objeto chapter-like para compatibilidade
                    const chapterToReprocess = {
                        number: failedChapter.chapterNumber,
                        id: ['', failedChapter.chapterId] // Formato esperado [?, chapterId]
                    };
                    
                    // Verificar se j√° foi baixado (pode ter sido corrigido manualmente)
                    if (chapterLogger.isChapterDownloaded(workName, failedChapter.chapterNumber)) {
                        console.log(`‚úÖ Cap√≠tulo ${failedChapter.chapterNumber} j√° foi corrigido - removendo das falhas`);
                        reprocessSuccess = true;
                        break;
                    }
                    
                    // Tentar baixar novamente
                    const pages = await provider.getPages(chapterToReprocess);
                    console.log(`üìÑ Total de P√°ginas: ${pages.pages.length}`);
                    
                    if (pages.pages.length === 0) {
                        throw new Error(`Cap√≠tulo ${failedChapter.chapterNumber} ainda retorna 0 p√°ginas`);
                    }
                    
                    // Baixar todas as p√°ginas
                    const sanitizedName = workName.replace(`Cap√≠tulo`, ``).replace(/[\\\/:*?"<>|]/g, '-');
                    
                    await Bluebird.map(pages.pages, async (pageUrl, pageIndex) => {
                        const capitulo = (pageIndex + 1) <= 9 ? `0${pageIndex + 1}` : `${pageIndex + 1}`;
                        console.log(`üì• Baixando P√°gina ${capitulo}: ${pageUrl}`);
                        
                        const dirPath = path.join('manga', path.normalize(sanitizedName), failedChapter.chapterNumber.toString());
                        
                        if (!fs.existsSync(dirPath)) {
                            fs.mkdirSync(dirPath, { recursive: true });
                        }
                        
                        const imagePath = path.join(dirPath, `${capitulo}.jpg`);
                        await downloadImage(pageUrl, imagePath);
                    }, { concurrency: 5 });
                    
                    console.log(`‚úÖ RENTRY SUCESSO: ${failedChapter.chapterNumber} baixado com sucesso na tentativa ${attempt}`);
                    fs.appendFileSync(reportFile, `RENTRY SUCESSO: ${failedChapter.chapterNumber} - tentativa ${attempt}\n`);
                    
                    // Salvar como sucesso e remover das falhas
                    const downloadPath = path.join('manga', path.normalize(sanitizedName), failedChapter.chapterNumber.toString());
                    chapterLogger.saveChapterSuccess(workName, failedChapter.workId, failedChapter.chapterNumber, failedChapter.chapterId, pages.pages.length, downloadPath);
                    
                    reprocessSuccess = true;
                    totalReprocessed++;
                    break;
                    
                } catch (error) {
                    lastError = error;
                    console.error(`‚ùå RENTRY tentativa ${attempt}/${maxRetries} falhou: ${error.message}`);
                    fs.appendFileSync(reportFile, `RENTRY ERRO tentativa ${attempt}: ${error.message}\n`);
                    
                    // Para erros de prote√ß√£o anti-bot, esperar mais tempo antes da pr√≥xima tentativa
                    if (error.message.includes('anti-bot') || error.message.includes('ofuscado')) {
                        const extraDelay = 5000 * attempt; // 5s, 10s, 15s extra
                        console.log(`üõ°Ô∏è Prote√ß√£o anti-bot detectada - aguardando ${extraDelay/1000}s extra...`);
                        await new Promise(resolve => setTimeout(resolve, extraDelay));
                    }
                }
            }
            
            if (!reprocessSuccess) {
                console.log(`üíÄ RENTRY falhou definitivamente: ${failedChapter.chapterNumber} - ${lastError?.message}`);
                fs.appendFileSync(reportFile, `RENTRY FALHA FINAL: ${failedChapter.chapterNumber} - ${lastError?.message}\n`);
                totalStillFailed++;
            }
        }
        
        console.log(`\nüìä Obra ${workIndex + 1} reprocessada: ${workName}`);
    }
    
    console.log('\n' + '='.repeat(80));
    console.log('üìä RESULTADO FINAL DO RENTRY AUTOM√ÅTICO');
    console.log('='.repeat(80));
    console.log(`‚úÖ Cap√≠tulos corrigidos: ${totalReprocessed}`);
    console.log(`‚ùå Cap√≠tulos ainda com falha: ${totalStillFailed}`);
    console.log(`üìà Taxa de sucesso: ${totalReprocessed > 0 ? Math.round((totalReprocessed / (totalReprocessed + totalStillFailed)) * 100) : 0}%`);
    
    fs.appendFileSync(reportFile, `\n${'='.repeat(80)}\nRESULTADO RENTRY: ${totalReprocessed} sucessos, ${totalStillFailed} falhas\n${'='.repeat(80)}\n`);
    
    if (totalStillFailed === 0) {
        console.log('üéâ Todas as falhas foram corrigidas!');
    } else {
        console.log(`‚ö†Ô∏è ${totalStillFailed} cap√≠tulos ainda precisam de aten√ß√£o manual`);
    }
}

async function executeCyclicRecovery(): Promise<void> {
    const chapterLogger = new ChapterLogger();
    const reportFile = 'download_report.txt';
    let cycleCount = 0;
    const maxCycles = 10; // M√°ximo de 10 tentativas de rentry
    
    console.log('\n' + '='.repeat(90));
    console.log('üîÑ MODO CICLO AUTOM√ÅTICO DE RENTRY ATIVADO');
    console.log('='.repeat(90));
    console.log('üìù Estrat√©gia: M√∫ltiplas tentativas de rentry at√© eliminar todas as falhas');
    console.log('‚ö° Cada ciclo d√° novas chances para cap√≠tulos que falharam anteriormente');
    console.log('='.repeat(90));
    
    fs.appendFileSync(reportFile, `\n${'='.repeat(90)}\nüîÑ MODO CICLO AUTOM√ÅTICO DE RENTRY INICIADO\n${'='.repeat(90)}\n`);
    
    while (cycleCount < maxCycles) {
        cycleCount++;
        
        console.log(`\nüîÑ === CICLO DE RENTRY ${cycleCount}/${maxCycles} ===`);
        fs.appendFileSync(reportFile, `\n=== CICLO DE RENTRY ${cycleCount} ===\n`);
        
        // Verificar se ainda h√° falhas para processar
        if (!chapterLogger.hasFailedChapters()) {
            console.log('‚úÖ Nenhuma falha encontrada - ciclo autom√°tico conclu√≠do!');
            fs.appendFileSync(reportFile, 'CICLO CONCLU√çDO: Nenhuma falha restante\n');
            break;
        }
        
        // Mostrar status atual das falhas
        const failedWorks = chapterLogger.getAllFailedChapters();
        const totalFailedChapters = failedWorks.reduce((acc, work) => acc + work.chapters.length, 0);
        
        console.log(`üìä Status antes do Ciclo ${cycleCount}:`);
        console.log(`   üìÅ Obras com falhas: ${failedWorks.length}`);
        console.log(`   üìÑ Cap√≠tulos falhados: ${totalFailedChapters}`);
        
        failedWorks.forEach(work => {
            console.log(`   - ${work.workName}: ${work.chapters.length} cap√≠tulos`);
        });
        
        // Aplicar timeouts progressivos para este ciclo
        const timeoutManager = TimeoutManager.getInstance();
        timeoutManager.setCycle(cycleCount);
        
        if (cycleCount > 1) {
            const increasePercent = timeoutManager.getIncreasePercentage();
            console.log(`üïê Aplicando timeouts progressivos: +${increasePercent}% (Ciclo ${cycleCount})`);
        }
        
        // Executar rentry
        console.log(`\nüîÑ Executando RENTRY - Ciclo ${cycleCount}`);
        console.log('-'.repeat(60));
        
        const reprocessedCount = await executeRentryPhase(cycleCount);
        
        // Verificar se rentry resolveu todas as falhas
        if (!chapterLogger.hasFailedChapters()) {
            console.log('üéâ Rentry resolveu todas as falhas - ciclo conclu√≠do!');
            fs.appendFileSync(reportFile, `CICLO ${cycleCount} CONCLU√çDO: Rentry resolveu todas as falhas\n`);
            break;
        }
        
        // Se n√£o houve progresso, parar o ciclo
        if (reprocessedCount === 0) {
            console.log(`‚ö†Ô∏è Ciclo ${cycleCount} n√£o corrigiu nenhuma falha - parando ciclo autom√°tico`);
            console.log('üìã Falhas restantes s√£o persistentes e requerem aten√ß√£o manual');
            fs.appendFileSync(reportFile, `CICLO ${cycleCount}: Sem progresso - falhas persistentes\n`);
            break;
        }
        
        console.log(`\nüìä Resultado do Ciclo ${cycleCount}:`);
        console.log(`   ‚úÖ Cap√≠tulos corrigidos: ${reprocessedCount}`);
        console.log(`   üìà Progresso positivo - continuando...`);
        
        // Pequena pausa entre ciclos
        console.log('‚è≥ Aguardando 3 segundos antes do pr√≥ximo ciclo...');
        await new Promise(resolve => setTimeout(resolve, 3000));
    }
    
    // Relat√≥rio final do ciclo
    const finalFailedWorks = chapterLogger.getAllFailedChapters();
    const finalFailedCount = finalFailedWorks.reduce((acc, work) => acc + work.chapters.length, 0);
    
    console.log('\n' + '='.repeat(90));
    console.log('üìä RELAT√ìRIO FINAL DO CICLO AUTOM√ÅTICO DE RENTRY');
    console.log('='.repeat(90));
    console.log(`üîÑ Ciclos de rentry executados: ${cycleCount}`);
    console.log(`üìÑ Falhas restantes: ${finalFailedCount} cap√≠tulos`);
    
    if (finalFailedCount === 0) {
        console.log('üéâ SUCESSO TOTAL: Todas as falhas foram eliminadas!');
        console.log('üèÜ O ciclo autom√°tico conseguiu corrigir 100% das falhas!');
        fs.appendFileSync(reportFile, `\nSUCESSO TOTAL: Ciclo eliminou todas as falhas em ${cycleCount} itera√ß√µes\n`);
    } else {
        console.log('‚ö†Ô∏è Falhas persistentes que requerem aten√ß√£o manual:');
        finalFailedWorks.forEach(work => {
            console.log(`   - ${work.workName}: ${work.chapters.length} cap√≠tulos`);
            work.chapters.forEach(ch => {
                console.log(`     ‚ùå ${ch.chapterNumber}: ${ch.errorMessage}`);
            });
        });
        fs.appendFileSync(reportFile, `\nCiclo finalizado com ${finalFailedCount} falhas persistentes\n`);
        
        const totalInitialFailed = 'desconhecido'; // Poderia calcular se salv√°ssemos o estado inicial
        console.log(`üìà Muitas falhas podem ter sido corrigidas durante os ${cycleCount} ciclos!`);
    }
    
    // Restaurar timeouts para valores padr√£o ap√≥s completar ciclos
    const timeoutManager = TimeoutManager.getInstance();
    timeoutManager.resetToDefaults();
    provider.resetTimeouts();
    
    console.log('='.repeat(90));
}

async function executeRentryPhase(cycleNumber: number): Promise<number> {
    console.log(`üîÑ Executando fase RENTRY do ciclo ${cycleNumber}...`);
    
    const chapterLogger = new ChapterLogger();
    const initialFailedWorks = chapterLogger.getAllFailedChapters();
    const initialFailedCount = initialFailedWorks.reduce((acc, work) => acc + work.chapters.length, 0);
    
    // Configurar timeouts para este ciclo
    const timeoutManager = TimeoutManager.getInstance();
    timeoutManager.setCycle(cycleNumber);
    
    // Executar rentry
    await executeAutoRentry();
    
    // Calcular quantos foram corrigidos
    const finalFailedWorks = chapterLogger.getAllFailedChapters();
    const finalFailedCount = finalFailedWorks.reduce((acc, work) => acc + work.chapters.length, 0);
    
    const correctedCount = initialFailedCount - finalFailedCount;
    console.log(`üìä Rentry fase: ${correctedCount} cap√≠tulos corrigidos`);
    
    return correctedCount;
}


async function downloadManga() {
    const provider = new NewSussyToonsProvider();
    const reportFile = 'download_report.txt';
    const failsFile = 'url_fails.txt';
    const args = process.argv.slice(2);
    const isBatchMode = args.includes('urls');
    const isRetryMode = args.includes('rentry');
    const maxRetries = 3;
    const chapterLogger = new ChapterLogger();

    try {
        let mangaUrls: string[] = [];
        
        if (isRetryMode) {
            console.log('üîÅ Modo rentry manual ativado - usando sistema de logs...');
            await executeAutoRentry();
            return;
        } else if (isBatchMode) {
            console.log('üîÑ Modo batch ativado - processando m√∫ltiplas URLs...');
            const urlsFile = 'obra_urls.txt';
            if (!fs.existsSync(urlsFile)) {
                console.error(`‚ùå Arquivo ${urlsFile} n√£o encontrado!`);
                return;
            }
            const urlsContent = fs.readFileSync(urlsFile, 'utf-8');
            mangaUrls = urlsContent.split('\n').filter(url => url.trim().length > 0);
            console.log(`üìã Encontradas ${mangaUrls.length} URLs para processar`);
        } else {
            const mangaUrl = await promptUser('Digite a URL da obra: ') as string;
            mangaUrls = [mangaUrl];
        }

        fs.writeFileSync(reportFile, `Relat√≥rio de Download - ${isRetryMode ? 'Reprocessamento de Falhas' : isBatchMode ? 'M√∫ltiplas Obras' : 'Obra √önica'}\n\n`);
        
        const successfulUrls: string[] = [];
        const failedUrls: string[] = [];

        await Bluebird.map(mangaUrls, async (mangaUrl, urlIndex) => {
            console.log(`\n${'='.repeat(60)}`);
            console.log(`üöÄ Processando obra ${urlIndex + 1}/${mangaUrls.length}: ${mangaUrl}`);
            console.log(`${'='.repeat(60)}`);
            
            try {
                const manga = await provider.getManga(mangaUrl);
                console.log('\n=== Informa√ß√µes do Manga ===');
                console.log('T√≠tulo:', manga.name);
                console.log('Link:', manga.id);

                fs.appendFileSync(reportFile, `\n=== OBRA ${urlIndex + 1}: ${manga.name} ===\n`);

                console.log('\nüîç Carregando lista de cap√≠tulos...');
                const chapters = await provider.getChapters(manga.id);

                if (chapters.length === 0) {
                    throw new Error(`Nenhum cap√≠tulo encontrado para ${manga.name}`);
                }

                // Extrair ID da obra para o log
                const workMatch = mangaUrl.match(/\/obra\/(\d+)/);
                const workId = workMatch ? workMatch[1] : 'unknown';
                
                // Criar nome sanitizado uma vez para reutilizar
                const sanitizedName = manga.name?.replace(`Cap√≠tulo`, ``).replace(/[\\\/:*?"<>|]/g, '-');
                
                // Verificar se obra j√° tem logs
                chapterLogger.hasWorkLogs(manga.name);
                
                console.log('\n=== Cap√≠tulos Dispon√≠veis no Site ===');
                chapters.forEach((chapter, index) => {
                    console.log(`√çndice: ${index} - Cap√≠tulo: ${chapter.number}`);
                });
                
                let selectedChapters = [];
                
                if (isBatchMode || isRetryMode) {
                    console.log('\nüîç Detectando cap√≠tulos novos baseado nos logs...');
                    selectedChapters = chapterLogger.detectNewChapters(manga.name, chapters);
                    
                    if (selectedChapters.length === 0) {
                        console.log('‚úÖ Nenhum cap√≠tulo novo detectado - obra j√° atualizada');
                        chapterLogger.showWorkStats(manga.name);
                        successfulUrls.push(mangaUrl);
                        return;
                    }
                    
                    console.log(`\nüì¶ Modo autom√°tico: baixando ${selectedChapters.length} cap√≠tulos (novos + falhas)...`);
                } else {
                    console.log('\nOp√ß√µes de Download:');
                    console.log('1. Baixar tudo');
                    console.log('2. Baixar intervalo de cap√≠tulos');
                    console.log('3. Escolher cap√≠tulos espec√≠ficos');
                    
                    const option = await promptUser('Escolha uma op√ß√£o (1, 2 ou 3): ');
                    
                    if (option === '1') {
                        selectedChapters = chapters;
                    } else if (option === '2') {
                        const start = parseInt(await promptUser('Digite o √≠ndice inicial do intervalo: '), 10);
                        const end = parseInt(await promptUser('Digite o √≠ndice final do intervalo: '), 10);
                        selectedChapters = chapters.slice(start, end + 1);
                    } else if (option === '3') {
                        const chaptersInput = await promptUser('Digite os √≠ndices dos cap√≠tulos que deseja baixar, separados por v√≠rgula (ex: 0,1,4): ');
                        const indices = chaptersInput.split(',').map(num => parseInt(num.trim(), 10));
                        selectedChapters = indices.map(index => chapters[index]).filter(chapter => chapter !== undefined);
                    } else {
                        throw new Error('Op√ß√£o inv√°lida selecionada.');
                    }
                }
                
                console.log('\nCap√≠tulos selecionados para download:');
                selectedChapters.forEach(chapter => console.log(`Cap√≠tulo: ${chapter.number}`));
                
                let failedChapters = 0;
                const totalChapters = selectedChapters.length;
                
                await Bluebird.map(selectedChapters, async (chapter) => {
                        console.log(`\n=== Processando Cap√≠tulo: ${chapter.number} ===`);
                        
                        // Verificar se o cap√≠tulo j√° foi baixado (PRIORIDADE 1: LOGS)
                        if (chapterLogger.isChapterDownloaded(manga.name, chapter.number)) {
                            console.log(`‚è≠Ô∏è Cap√≠tulo ${chapter.number} j√° baixado (confirmado por log) - pulando...`);
                            fs.appendFileSync(reportFile, `Cap√≠tulo ${chapter.number} - J√Å BAIXADO (confirmado por log)\n`);
                            return;
                        }
                        
                        // Verifica√ß√£o secund√°ria na pasta f√≠sica (apenas como backup)
                        const chapterDir = path.join('manga', path.normalize(sanitizedName), chapter.number.toString());
                        
                        if (fs.existsSync(chapterDir)) {
                            const existingFiles = fs.readdirSync(chapterDir);
                            if (existingFiles.length > 0) {
                                console.log(`‚ö†Ô∏è Cap√≠tulo ${chapter.number} existe na pasta mas sem log - criando log de sucesso...`);
                                // Criar log retroativo para manter consist√™ncia
                                chapterLogger.saveChapterSuccess(manga.name, workId, chapter.number, chapter.id[1], existingFiles.length, chapterDir);
                                fs.appendFileSync(reportFile, `Cap√≠tulo ${chapter.number} - LOG RETROATIVO CRIADO\n`);
                                return;
                            }
                        }
                        
                        fs.appendFileSync(reportFile, `Cap√≠tulo: ${chapter.number}\n`);
                        
                        // Sistema de retry para cap√≠tulo individual
                        let chapterSuccess = false;
                        let lastChapterError = null;
                        
                        for (let chapterAttempt = 1; chapterAttempt <= maxRetries; chapterAttempt++) {
                            try {
                                if (chapterAttempt > 1) {
                                    console.log(`üîÑ Tentativa ${chapterAttempt}/${maxRetries} para cap√≠tulo: ${chapter.number}`);
                                    await new Promise(resolve => setTimeout(resolve, 1000 * chapterAttempt));
                                }
                                // Obter as p√°ginas do cap√≠tulo com timeout de seguran√ßa
                                console.log(`‚è±Ô∏è Obtendo p√°ginas (timeout: ${TimeoutManager.getInstance().getTimeout('request')/1000}s)...`);
                                const pages = await Promise.race([
                                    provider.getPages(chapter),
                                    new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error('Timeout na obten√ß√£o de p√°ginas')), 
                                            TimeoutManager.getInstance().getTimeout('request'))
                                    )
                                ]);
                                console.log(`Total de P√°ginas: ${pages.pages.length}`);

                                if (pages.pages.length === 0) {
                                    throw new Error(`Cap√≠tulo ${chapter.number} retornou 0 p√°ginas`);
                                }
                    
                                await Bluebird.map(pages.pages, async (pageUrl, pageIndex) => {
                                    const capitulo = (pageIndex + 1 ) <= 9 ? `0${pageIndex + 1}` :`${pageIndex + 1}`
                                    console.log(`Baixando P√°gina ${capitulo}: ${pageUrl}`);
                            
                                    // Criar o diret√≥rio para o cap√≠tulo
                                    const dirPath = path.join('manga', path.normalize(sanitizedName), chapter.number.toString());
                            
                                    // Verificar se o diret√≥rio existe, se n√£o, criar
                                    if (!fs.existsSync(dirPath)) {
                                        fs.mkdirSync(dirPath, { recursive: true });
                                    }
                            
                                    // Caminho completo para salvar a imagem
                                    const imagePath = path.join(dirPath, `${capitulo}.jpg`);
                            
                                    // Baixar a imagem
                                    await downloadImage(pageUrl, imagePath);
                                }, { concurrency: 5 });
                        
                                console.log(`‚úÖ Cap√≠tulo ${chapter.number} baixado com sucesso na tentativa ${chapterAttempt}`);
                                fs.appendFileSync(reportFile, `Cap√≠tulo ${chapter.number} baixado com sucesso.\n`);
                                
                                // Salvar log individual do cap√≠tulo
                                const downloadPath = path.join('manga', path.normalize(sanitizedName), chapter.number.toString());
                                chapterLogger.saveChapterSuccess(manga.name, workId, chapter.number, chapter.id[1], pages.pages.length, downloadPath);
                                
                                chapterSuccess = true;
                                break;
                                
                            } catch (error) {
                                lastChapterError = error;
                                console.error(`‚ùå Tentativa ${chapterAttempt}/${maxRetries} falhou para cap√≠tulo ${chapter.number}: ${error.message}`);
                                fs.appendFileSync(reportFile, `ERRO tentativa ${chapterAttempt}: ${error.message}\n`);
                                
                                // Para erros de prote√ß√£o anti-bot, esperar mais tempo antes da pr√≥xima tentativa
                                if (error.message.includes('anti-bot') || error.message.includes('ofuscado')) {
                                    const extraDelay = 3000 * chapterAttempt; // 3s, 6s, 9s extra
                                    console.log(`üõ°Ô∏è Prote√ß√£o anti-bot detectada - aguardando ${extraDelay/1000}s extra...`);
                                    await new Promise(resolve => setTimeout(resolve, extraDelay));
                                }
                                
                                if (chapterAttempt === maxRetries) {
                                    console.error(`üíÄ Todas as ${maxRetries} tentativas falharam para cap√≠tulo: ${chapter.number}`);
                                }
                            }
                        }
                        
                        // Se cap√≠tulo falhou ap√≥s 3 tentativas, salvar logs
                        if (!chapterSuccess) {
                            failedChapters++;
                            const chapterUrl = `https://www.sussytoons.wtf/capitulo/${chapter.id[1]}`;
                            
                            // Salvar log individual de falha
                            chapterLogger.saveChapterFailure(manga.name, workId, chapter.number, chapter.id[1], maxRetries, lastChapterError?.message || 'Erro desconhecido');
                            
                            if (isBatchMode || isRetryMode) {
                                console.log(`üíæ Salvando cap√≠tulo falhado: ${chapterUrl}`);
                                
                                // Ler falhas existentes
                                const existingFails = fs.existsSync(failsFile) ? 
                                    fs.readFileSync(failsFile, 'utf-8').split('\n').filter(url => url.trim().length > 0) : [];
                                
                                // Adicionar nova falha se n√£o existir
                                if (!existingFails.includes(chapterUrl)) {
                                    existingFails.push(chapterUrl);
                                    fs.writeFileSync(failsFile, existingFails.join('\n') + '\n');
                                    console.log(`‚úÖ Cap√≠tulo falhado salvo em ${failsFile}`);
                                }
                            }
                            
                            fs.appendFileSync(reportFile, `FALHA DEFINITIVA: Cap√≠tulo ${chapter.number} - ${lastChapterError?.message}\n`);
                        }
                    }, { concurrency: 2 });
                    
                    const failureRate = failedChapters / totalChapters;
                    console.log(`\nüìä Estat√≠sticas: ${totalChapters - failedChapters}/${totalChapters} cap√≠tulos baixados (${Math.round((1 - failureRate) * 100)}% sucesso)`);
                    
                    console.log(`\nüìä Primeira fase conclu√≠da: ${manga.name}`);
                    console.log(`üìä Estat√≠sticas: ${totalChapters - failedChapters}/${totalChapters} cap√≠tulos baixados (${Math.round((1 - failureRate) * 100)}% sucesso)`);
                    
                    // SEGUNDA FASE: Reprocessar falhas desta obra
                    if (failedChapters > 0) {
                        console.log(`\nüîÑ SEGUNDA FASE: Reprocessando ${failedChapters} cap√≠tulos falhados de ${manga.name}...`);
                        fs.appendFileSync(reportFile, `\n=== SEGUNDA FASE - REPROCESSAMENTO DE FALHAS ===\n`);
                        
                        // Ler falhas do arquivo que s√£o desta obra
                        const currentFails = fs.existsSync(failsFile) ? 
                            fs.readFileSync(failsFile, 'utf-8').split('\n').filter(url => url.trim().length > 0) : [];
                        
                        const thisWorkFails = currentFails.filter(url => {
                            // Extrair ID da obra da URL atual
                            const workMatch = mangaUrl.match(/\/obra\/(\d+)/);
                            if (!workMatch) return false;
                            const workId = workMatch[1];
                            
                            // Verificar se a URL de falha √© desta obra
                            return url.includes(`sussytoons.wtf`) && 
                                   (url.includes(`/obras/${workId}/`) || url.includes(`/capitulo/`));
                        });
                        
                        console.log(`üìã Encontradas ${thisWorkFails.length} falhas desta obra para reprocessar`);
                        
                        if (thisWorkFails.length > 0) {
                            const reprocessedSuccesses: string[] = [];
                            const finalFails: string[] = [];
                            
                            for (const failUrl of thisWorkFails) {
                                console.log(`\nüîÑ Reprocessando: ${failUrl}`);
                                
                                let reprocessSuccess = false;
                                let lastReprocessError = null;
                                
                                // 3 tentativas para reprocessar
                                for (let reprocessAttempt = 1; reprocessAttempt <= maxRetries; reprocessAttempt++) {
                                    try {
                                        if (reprocessAttempt > 1) {
                                            console.log(`üîÑ Tentativa ${reprocessAttempt}/${maxRetries} para reprocessamento: ${failUrl}`);
                                            await new Promise(resolve => setTimeout(resolve, 2000 * reprocessAttempt));
                                        }
                                        
                                        // Extrair ID do cap√≠tulo da URL
                                        const chapterMatch = failUrl.match(/\/capitulo\/(\d+)/);
                                        if (!chapterMatch) throw new Error('URL de cap√≠tulo inv√°lida');
                                        
                                        const chapterId = chapterMatch[1];
                                        
                                        // Encontrar o cap√≠tulo na lista
                                        const chapterToReprocess = selectedChapters.find(ch => ch.id[1] === chapterId);
                                        if (!chapterToReprocess) throw new Error('Cap√≠tulo n√£o encontrado na lista');
                                        
                                        // Verificar se j√° foi baixado durante reprocessamento (PRIORIDADE 1: LOGS)
                                        if (chapterLogger.isChapterDownloaded(manga.name, chapterToReprocess.number)) {
                                            console.log(`‚úÖ Cap√≠tulo ${chapterToReprocess.number} j√° foi baixado (confirmado por log) durante reprocessamento`);
                                            reprocessSuccess = true;
                                            break;
                                        }
                                        
                                        // Verifica√ß√£o secund√°ria na pasta f√≠sica
                                        const chapterDirReprocess = path.join('manga', path.normalize(sanitizedName), chapterToReprocess.number.toString());
                                        
                                        if (fs.existsSync(chapterDirReprocess)) {
                                            const existingFiles = fs.readdirSync(chapterDirReprocess);
                                            if (existingFiles.length > 0) {
                                                console.log(`‚ö†Ô∏è Cap√≠tulo ${chapterToReprocess.number} existe na pasta mas sem log - criando log retroativo...`);
                                                // Criar log retroativo
                                                chapterLogger.saveChapterSuccess(manga.name, workId, chapterToReprocess.number, chapterToReprocess.id[1], existingFiles.length, chapterDirReprocess);
                                                reprocessSuccess = true;
                                                break;
                                            }
                                        }
                                        
                                        // Tentar baixar novamente
                                        const pages = await provider.getPages(chapterToReprocess);
                                        console.log(`Total de P√°ginas: ${pages.pages.length}`);
                                        
                                        if (pages.pages.length === 0) {
                                            throw new Error(`Cap√≠tulo ${chapterToReprocess.number} ainda retorna 0 p√°ginas`);
                                        }
                                        
                                        await Bluebird.map(pages.pages, async (pageUrl, pageIndex) => {
                                            const capitulo = (pageIndex + 1 ) <= 9 ? `0${pageIndex + 1}` :`${pageIndex + 1}`
                                            console.log(`Baixando P√°gina ${capitulo}: ${pageUrl}`);
                                    
                                            // Criar o diret√≥rio para o cap√≠tulo
                                            const dirPath = path.join('manga', path.normalize(sanitizedName), chapterToReprocess.number.toString());
                                    
                                            if (!fs.existsSync(dirPath)) {
                                                fs.mkdirSync(dirPath, { recursive: true });
                                            }
                                    
                                            const imagePath = path.join(dirPath, `${capitulo}.jpg`);
                                            await downloadImage(pageUrl, imagePath);
                                        }, { concurrency: 5 });
                                        
                                        console.log(`‚úÖ Reprocessamento bem-sucedido: Cap√≠tulo ${chapterToReprocess.number}`);
                                        fs.appendFileSync(reportFile, `REPROCESSAMENTO SUCESSO: Cap√≠tulo ${chapterToReprocess.number}\n`);
                                        
                                        // Salvar log individual do cap√≠tulo reprocessado
                                        const downloadPath = path.join('manga', path.normalize(sanitizedName), chapterToReprocess.number.toString());
                                        chapterLogger.saveChapterSuccess(manga.name, workId, chapterToReprocess.number, chapterToReprocess.id[1], pages.pages.length, downloadPath);
                                        reprocessSuccess = true;
                                        break;
                                        
                                    } catch (error) {
                                        lastReprocessError = error;
                                        console.error(`‚ùå Reprocessamento tentativa ${reprocessAttempt}/${maxRetries} falhou: ${error.message}`);
                                        fs.appendFileSync(reportFile, `REPROCESSAMENTO ERRO tentativa ${reprocessAttempt}: ${error.message}\n`);
                                    }
                                }
                                
                                if (reprocessSuccess) {
                                    reprocessedSuccesses.push(failUrl);
                                } else {
                                    finalFails.push(failUrl);
                                    console.log(`üíÄ Reprocessamento falhou definitivamente: ${failUrl}`);
                                    fs.appendFileSync(reportFile, `REPROCESSAMENTO FALHA FINAL: ${failUrl} - ${lastReprocessError?.message}\n`);
                                }
                            }
                            
                            // Atualizar arquivo de falhas
                            const remainingFails = currentFails.filter(url => !reprocessedSuccesses.includes(url));
                            
                            // Marcar falhas finais com flag especial
                            const markedFinalFails = finalFails.map(url => `${url} # TODAS_TENTATIVAS_ESGOTADAS`);
                            const updatedFails = [...remainingFails.filter(url => !finalFails.includes(url.split(' #')[0])), ...markedFinalFails];
                            
                            if (updatedFails.length === 0) {
                                if (fs.existsSync(failsFile)) {
                                    fs.unlinkSync(failsFile);
                                    console.log(`üóëÔ∏è Arquivo de falhas removido - todas as falhas foram resolvidas!`);
                                }
                            } else {
                                fs.writeFileSync(failsFile, updatedFails.join('\n') + '\n');
                                console.log(`üìù Arquivo de falhas atualizado`);
                            }
                            
                            console.log(`\nüìä Resultado do reprocessamento:`);
                            console.log(`‚úÖ Sucessos: ${reprocessedSuccesses.length}`);
                            console.log(`‚ùå Falhas finais: ${finalFails.length}`);
                            
                            fs.appendFileSync(reportFile, `\nRESULTADO REPROCESSAMENTO: ${reprocessedSuccesses.length} sucessos, ${finalFails.length} falhas finais\n`);
                        }
                    }
                    
                    // Mostrar estat√≠sticas da obra
                    chapterLogger.showWorkStats(manga.name);
                    
                    console.log(`\n‚úÖ Obra ${urlIndex + 1} TOTALMENTE conclu√≠da: ${manga.name}`);
                    fs.appendFileSync(reportFile, `=== FIM COMPLETO DA OBRA ${urlIndex + 1}: ${manga.name} ===\n\n`);
                    successfulUrls.push(mangaUrl);
                    
            } catch (error) {
                console.error(`‚ùå Erro cr√≠tico ao processar obra ${urlIndex + 1} (${mangaUrl}): ${error.message}`);
                fs.appendFileSync(reportFile, `ERRO CR√çTICO na obra: ${error.message}\n\n`);
                failedUrls.push(mangaUrl);
            }
        }, { concurrency: 1 });
        
        console.log('\nüìä Resultado Final:');
        console.log(`‚úÖ Sucessos: ${successfulUrls.length}`);
        console.log(`‚ùå Falhas: ${failedUrls.length}`);
        
        if (isRetryMode && successfulUrls.length > 0) {
            console.log('\nüßπ Removendo URLs bem-sucedidas do arquivo de falhas...');
            const remainingFails = mangaUrls.filter(url => !successfulUrls.includes(url));
            if (remainingFails.length === 0) {
                if (fs.existsSync(failsFile)) {
                    fs.unlinkSync(failsFile);
                    console.log('üóëÔ∏è Arquivo de falhas removido - todas as falhas foram resolvidas!');
                }
            } else {
                fs.writeFileSync(failsFile, remainingFails.join('\n') + '\n');
                console.log(`üìù Arquivo de falhas atualizado. Restam ${remainingFails.length} falhas.`);
            }
        } else if (failedUrls.length > 0 && !isBatchMode && !isRetryMode) {
            // Salvar falhas apenas se n√£o for modo batch (no batch j√° foram salvas imediatamente)
            const existingFails = fs.existsSync(failsFile) ? 
                fs.readFileSync(failsFile, 'utf-8').split('\n').filter(url => url.trim().length > 0) : [];
            
            const allFails = [...new Set([...existingFails, ...failedUrls])];
            fs.writeFileSync(failsFile, allFails.join('\n') + '\n');
            console.log(`üíæ ${failedUrls.length} falhas salvas em ${failsFile}`);
        } else if (isBatchMode && failedUrls.length > 0) {
            console.log(`üìù ${failedUrls.length} falhas j√° foram salvas individualmente durante o processamento`);
        }
        
        console.log('\nüéâ Processamento batch completo. Relat√≥rio salvo em:', reportFile);
        
        // Ativar ciclo autom√°tico se houver falhas nos logs
        if (isBatchMode && !isRetryMode) {
            await executeCyclicRecovery();
        }
    } catch (error) {
        console.error('Erro durante a execu√ß√£o:', error);
        fs.appendFileSync(reportFile, `Erro durante a execu√ß√£o: ${error.message}\n`);
    }
}

downloadManga();
